{"pages":[{"title":"","text":"唐艺昕 李沁 李一桐 gakki 图片搜集于互联网，侵权请留言，马上处理😊。","link":"/album/index.html"},{"title":"","text":"个人简介 个人信息: 物联网工程专业 现为大二学生 兴趣广泛，各种东西都了解一点点，主要偏向web前后的开发 坚信代码改变世界 ……未完待续","link":"/about/index.html"},{"title":"","text":"申请友链须知 原则上只和技术类博客交换，但不包括含有和色情、暴力、政治敏感的网站。 不和剽窃、侵权、无诚信的网站交换，优先和具有原创作品的网站交换。 申请请提供：站点名称、站点链接、站点描述、logo或头像（不要设置防盗链）。 排名不分先后，刷新后重排，更新信息后请留言告知。 会定期清理很久很久不更新的、不符合要求的友链，不再另行通知。 本站不存储友链图片，如果友链图片换了无法更新。图片裂了的会替换成默认图，需要更换的请留言告知。 本站友链信息如下，申请友链前请先添加本站信息： 网站图标：https://removeif.github.io/images/avatar.jpg 网站名称：Blog of Shikang Xu 网站地址：https://XuShiKang.github.io 网站简介：菜鸟程序员，技术分享 加载中，稍等几秒...","link":"/friend/index.html"},{"title":"","text":"万物理论 && 听见下雨的声音 Are you ok?","link":"/media/index.html"},{"title":"音乐歌单收藏","text":"--- 温馨提示：选择喜欢的音乐双击播放，由于版权原因部分不能播放。如果喜欢歌单收藏一下，去网易云都能播放哟！","link":"/music/index.html"},{"title":"","text":"来而不往非礼也畅所欲言，有留必应","link":"/message/index.html"},{"title":"","text":"碎碎念 tips：github登录后按时间正序查看、可点赞加❤️、本插件地址..「+99次查看」 var gitalk = new Gitalk({ clientID: '46a9f3481b46ea0129d8', clientSecret: '79c7c9cb847e141757d7864453bcbf89f0655b24', id: '666666', repo: 'issue_database', owner: 'removeif', admin: \"removeif\", createIssueManually: true, distractionFreeMode: false }) gitalk.render('comment-container1')","link":"/self-talking/index.html"},{"title":"","text":"@font-face { font-family: digit; src: url('digital-7_mono.ttf') format(\"truetype\"); } body { margin: 0; padding: 0; background: #ffe; font-size: 12px; overflow: auto } #loveHeart { float: left; width: 670px; height: 625px } #garden { width: 100%; height: 100% } #elapseClock { text-align: right; font-size: 18px; margin-top: 10px; margin-bottom: 10px } #words { font-family: \"sans-serif\"; width: 500px; font-size: 24px; color: #666 } #messages { display: none } #elapseClock .digit { font-family: \"digit\"; font-size: 36px } #loveu { padding: 5px; font-size: 22px; margin-top: 80px; margin-right: 120px; text-align: right; display: none } #loveu .signature { margin-top: 10px; font-size: 20px; font-style: italic; margin-right: 16px; } function Vector(a, b) { this.x = a; this.y = b } Vector.prototype = { rotate: function (b) { var a = this.x; var c = this.y; this.x = Math.cos(b) * a - Math.sin(b) * c; this.y = Math.sin(b) * a + Math.cos(b) * c; return this }, mult: function (a) { this.x *= a; this.y *= a; return this }, clone: function () { return new Vector(this.x, this.y) }, length: function () { return Math.sqrt(this.x * this.x + this.y * this.y) }, subtract: function (a) { this.x -= a.x; this.y -= a.y; return this }, set: function (a, b) { this.x = a; this.y = b; return this } }; function Petal(a, f, b, e, c, d) { this.stretchA = a; this.stretchB = f; this.startAngle = b; this.angle = e; this.bloom = d; this.growFactor = c; this.r = 1; this.isfinished = false } Petal.prototype = { draw: function () { var a = this.bloom.garden.ctx; var e, d, c, b; e = new Vector(0, this.r).rotate(Garden.degrad(this.startAngle)); d = e.clone().rotate(Garden.degrad(this.angle)); c = e.clone().mult(this.stretchA); b = d.clone().mult(this.stretchB); a.strokeStyle = this.bloom.c; a.beginPath(); a.moveTo(e.x, e.y); a.bezierCurveTo(c.x, c.y, b.x, b.y, d.x, d.y); a.stroke() }, render: function () { if (this.r","link":"/lover/index.html"}],"posts":[{"title":"使用Hexo创建博客","text":"11].pdf`) 环境准备安装node.js和git Node.js Git 安装Hexo准备好环境后，即可使用npm安装Hexo脚手架 $ npm install -g hexo-cli 开始搭建 $ hexo init # 创建项目 $ cd # 进入项目文件夹 $ npm install # 安装node依赖 项目目录结构如下123456789.├── _config.yml├── package.json├── scaffolds├── source ├── _drafts └── _posts└── themes └──landscape 在source/_posts下新建markdown文件即可开始写作 官方写作规范 运行 $ hexo server或者$ npm server 在localhost:4000即可访问博客 配置网站信息编辑_config.yml即可修改网站信息，配置信息文档 发布网站 $ hexo generate或者$ npm bulid 项目根目录文件夹下的public文件夹即为构建产物文件夹 将public发布为静态网站即可","link":"/posts/ed236c80/"},{"title":"使用Hexo + GitHub Pages创建博客","text":"搭建博客使用hexo搭建博客，具体过程点我 配置github pages新建一个github repo 项目名为&lt;yourUserName&gt;.github.io 最简单的方法，将构建产物public push到这个项目，博客就搭建起来了 然后通过&lt;yourUserName&gt;.github.io即可访问你的博客 生成Github token点击setting 然后点击Developer Settings -&gt; Personal access tokens -&gt; Generate new token 填写表单即可生成token 配置项目_config.yml修改deploy部分，官方文档 12345deploy: - type: git repo: https://github.com/&lt;username&gt;/&lt;username&gt;.github.io.git branch: &lt;yourBranch&gt; token: &lt;yourToken&gt; 发布博客 $ hexo deploy或者$ npm deploy 然后访问&lt;yourUserName&gt;.github.io即可","link":"/posts/2149ef24/"},{"title":"微机原理知识汇总","text":"计算机组成冯诺依曼计算机架构 以运算器为核心、以存储程序原理为基础 组成 运算器 控制器 存储器 输入设备 输出设备 采用二进制进行运算，数据与程序均以二进制形式存放在存储器中 将计算任务分解为若干步骤，每个步骤用指令实现，指令序列即为程序 在CPU的控制下自动进行运算 特点 程序存储，共享数据，顺序执行 属于顺序处理机，适合确定的算法和数值数据的处理 不足 与存储器间大量数据交互，对总线要求高 执行顺序由程序决定，对大型复杂任务较困难 以运算器为核心，处理效率较低 由PC(Program Count)控制执行顺序，难以实现真正的并行处理 微型计算机的工作过程 取一条指令的工作过程 指令所在地址赋给程序计数器PC并送到地址寄存器AR PC自动地址加1，AR的内容不变 将地址寄存器AR的内容放在地址总线上，并送至内存储器，经地址译码器译码，选中相应单元 CPU控制器发出读指令 在读指令的控制下，把选中内存单元的内容读到数据总线DB 将读出的内容经过数据总线送到数据寄存器DR 指令译码，DR将指令送到指令寄存器IR，然后再送到指令译码器ID 微处理器指令的执行过程执行一条指令需要执行的步骤 从存储器中取出指令 指令译码 读操作数(如果需要) 执行指令 写结果(如果需要) 微处理器组成 运算器 组成 算术逻辑单元 通用或专用寄存器组(可单独看成一个组成部分) 内部总线 功能 实现数据的算术运算及逻辑运算 控制器 组成 程序计数器 指令寄存器 指令译码器 时序控制部件 微操作控制部件 功能 指令控制 时序控制 操作控制 8086/8088 16位CPU 20位地址线，可寻址1M空间 8086总线宽度16位，8088总线宽度8位 采用+5V电源，频率位5MHz 采用并行流水线工作方式，通过设置指令预取队列实现(相当于有指令缓冲区) 对内存空间实行分段管理 支持多处理器系统 内部结构框图 8086/8088管脚及功能 管脚示意图 A_{16}-A_{19}/S_{3}-S_{6}: 地址、状态复用的引脚，三态输出 A_{8}-A_{15}: 中8位地址信号，三态输出 $AD_0-AD_7$: 地址、数据分时复用的双向信号线，三态 $IO/\\overline{M}$: 输入输出/存储器控制信号，三态。低电平访问存储器，高电平访问$I/O$端口 $\\overline{WR}$: 写信号输出，三态。低电平为写操作 $DT/\\overline{R}$: 数据传送方向控制信号，三态。高电平CPU发送数据，低电平CPU接受数据 $\\overline{DEN}$: 数据允许输出，三态。低电平表示DB的数据有效 $ALE$: 地址锁存信号，三态输出。高电平有效 $\\overline{RD}$: 读选通信号，三态输出，低电平有效 $READY$: 外部同步控制输入信号，高电平有效 $INTR$: 可屏蔽中断请求输出信号，高电平有效 $NMI$: 非屏蔽中断请求输入信号，上升沿触发 $\\overline{INTA}$: 中断响应信号输出，低电平有效 $HOLD$: 总线保持请求信号输入，高电平有效 $HLDA$: 总线保持响应信号输入，高电平有效 工作模式 最小模式系统中只有8086/8088一个处理器，所有的控制信号都由8086/8088CPU产生 最大模式系统可包含一个以上的处理器 当$MN/\\overline{MX}$加上低电平时，CPU工作在最大模式，反之则在最小模式下 8086/8088寄存器数据寄存器为避免累赘，例如AL，AH类8位寄存器不列举 AX(Accumulator): 累加器，通常用作数据传输媒介 BX(Base): 基址寄存器，通常用作存放内存的基地址，常与DS配合使用 CX(Count): 计数寄存器，在循环和串操作指令中做计数器 DX(Data): 数据寄存器，在寄存器间接寻址的I/O指令中存放I/O端口地址 地址指针寄存器 SP(Stack Pointer): 堆栈指针寄存器，它指向栈顶 BP(Bace Pointer): 基址指针寄存器，常用来存放内存的基地址，常配合SS来使用 变址寄存器 SI(Source Index): 源变址寄存器，用作索引指针 DI(Destination Index): 目的变址寄存器，用作索引指针 段寄存器存放相应段的段地址 CS(Code Segment): 代码段寄存器 SS(Stack Segment): 堆栈段寄存器 DS(Data Segment): 数据段寄存器 ES(Extra Segment): 附加段寄存器 控制寄存器 IP(Instructions Pointer): 指令指针寄存器 FLAGS: 标志寄存器 物理地址与逻辑地址的转换(存储器分段)物理地址 = 段基址 * 16 + 段内偏移地址 如段地址为1000H，偏移地址为1234H，则 物理地址 = $1000H * 16 + 1234H = 10000H + 1234H = 11234H$ 堆栈操作 每次压栈(PUSH)和退栈操作(POP)均以字(双字节)为单位 栈的增长方向是从高地址到低地址 如将82F0H压栈，[SP] = F0H，[SP+1] = 82H，如下图所示 内存中的数据特点 数据再内存中从低地址到高地址顺序存放 数据位大于8位时，高字节放在高地址，低字节放在低地址 数据的地址指它的最低字节所在内存单元的地址 系统总线 按传输数据类型分类 数据总线 地址总线 控制总线 按相对CPU位置分类 片内总线 片外总线 按层次结构分 CPU总线 系统总线 外部总线 总线结构 单总线结构：简单，但竞争严重 多总线结构：性能高，但组成复杂 性能指标 带宽 位宽 工作频率 $总线带宽 = (位宽/8)*(工作频率/每个存取周期的时钟数)$ 8086/8088指令系统寻址方式 立即寻址eg. MOV AX, 1200H 直接寻址eg. MOV AX, [8000H] 寄存器寻址eg. MOV AX, BX 寄存器间接寻址eg. MOV AX, [BX] 寄存器相对寻址eg. MOV AX, [BX + 1] 基址-变址寻址指令中不允许同时出现两个基址寄存器或者两个变址寄存器eg. MOV AX, [BX][SI] or MOV AX, [BX + SI] 基址-变址-相对寻址eg. MOV AX, [BX][SI]5 数据传送指令 MOV: 一般传输指令(源操作数和目标操作数不能同时为存储器操作数) PUSH/POP: 堆栈操作指令 PUSHF/POPF: 将标志寄存器压栈或者从堆栈弹出 XCHG: 交换指令 IN/OUT: 输入输出指令 LEA: 取偏移地址指令 算术运算指令加法指令 ADD: 不考虑进位的加法指令 ADC: 带进位的加法指令 INC: 加一指令 减法指令 SUB: 不考虑借位减法指令 SBB: 带借位的减法指令 DEC: 减一指令 NEG: 求补指令 CMP: 比较指令 乘法指令 MUL: 乘法指令 除法指令 DIV: 除法指令 逻辑运算与移位指令逻辑指令 AND: 逻辑‘与’指令 OR: 逻辑‘或’指令 NOT: 逻辑‘非’指令 XOR: 逻辑‘异或’指令 TEST: 测试指令 移位指令 SAL: 算术左移指令 SAR: 算术右移指令 SHL: 逻辑左移指令 SHR: 逻辑右移指令 ROL: 不带进位的循环左移指令 ROR: 不带进位的循环右移指令 RCL: 带进位的循环左移指令 RCR: 带进位的循环右移指令 串操作指令要预先设置源串指针(DS:[SI])，目标串指针(ES:[DI])，重复次数(CX)，操作方向(DF)，使用CLD or STD 重复前缀共同特点，使用前要设置CX，每重复一次CX自减1，为0时停止 REP: 无条件重复 REPE(Repeat if Equal): 相等重复 REPZ(Repeat if Zero): 为0重复 REPNE(Repeat if Not Equal): 不相等重复 REPNZ(Repeat if Not Zero): 不为0重复 串操作指令每次循环会使SI和DI自增一个字或者字节(取决于指令) MOVS, MOVSB, MOVSW: 串传送 CMPS, CMPSB, CMPSW: 串比较 SCAS, SCASB, SCASW: 串扫描 LODS, LODSB, LODSW: 串装入 STOS, STOSB, STOSB: 串送存 每种串操作有三种格式，第一种格式是需要手动设置操作数的，第二种是默认使用预先设置的源串指针(DS:[SI])，目标串指针(ES:[DI])来按字节操作，第三种则是按字操作 程序控制指令转移指令 JMP: 无条件转移指令(加修饰符FAR可段间调用) JC/JNC: 判断CF的状态，常用于比大小 JZ/JNZ: 判断ZF的状态，常用于循环体的结束判断 JO/JNO: 判断OF的状态，常用于有符号数的溢出判断 JP/JPE: 判断PF的状态，用于判断运算结果低八位1的个数是否为偶数 JA/JAE/JB/JBE: 判断CF或CF+ZF的状态，常用于无符号数的比较 更多指令查看下表 循环指令循环次数由预先设置的CX决定 LOOP: 无条件循环指令 过程调用和返回调用时将IP压入堆栈，如果是段间调用(FAR)还要先将CS压入堆栈 CALL: 调用子程序(加修饰符FAR可实现段间调用) RET: 从堆栈中弹出IP，返回到原程序 中断指令 INT: 中断程序调用，后跟中断类型码 执行过程 将FLAGS压入堆栈 将INT指令的下一条指令的CS、IP压栈 由中断类型码乘4获得中断向量存放的地址 将中断向量(中断服务程序入口地址)放入CS、IP 转入中断服务程序运行 IRET: 中断程序返回，恢复原程序的CS、IP、FLAGS 汇编","link":"/posts/35e906f3/"},{"title":"WSL的使用教程","text":"点我","link":"/posts/b609c41e/"},{"title":"HTTPS原理","text":"概念HTTPS = HTTP over TLS 握手HTTP只需要TCP握手，2*RTT HTTPS握手类型 完全握手多2*RTT 阶段一：Client =&gt; Server: 支持版本、密码套件Client &lt;= Server: 密码套件、证书 阶段二：Client =&gt; Server: 密钥交换、完成Client &lt;= Server: 完成 简化握手(TLS 1.2)多1*RTT不需要阶段二 0*RTT握手(TLS 1.3) HTTPS握手原因 身份认证(证书) =&gt; 防冒充确保正确的用户访问到正确的网站 证书的作用 确认身份 校验签名 传递公钥 数据加密 =&gt; 防窃听第三方无法直接查看原始内容 数据一致性 =&gt; 防篡改、防抵赖及时发现第三方对内容的篡改 Tip: 数字签名 签名过程：内容经过Hash运算得到摘要，将摘要用私钥加密作为签名 通过网络传输：将签名和文件一起发送 接收验证签名： 将内容进行Hash运算得到摘要，将签名用公钥解密也得到一份摘要，两份摘要进行比对使用Hash摘要的原因： 全文直接签名太耗费资源 Hash摘要可以保证内容修改任意部分，摘要都会变化 传输数据加密 对称加密加解密用同一个密钥 非对称加密密钥分为公钥和私钥可以用公钥加密私钥界面也可以私钥加密公钥解密 从性能上来说，对称加密比非对称加密快两个数量级 方案 握手阶段使用非对称加密，协商传输密钥 传输采用对称加密，速度快 访问速度 网络耗时最坏情况下会增加7个RTT 计算耗时客户端，50ms服务端，15ms","link":"/posts/d6e63596/"}],"tags":[{"name":"Web","slug":"Web","link":"/tags/Web/"},{"name":"Node.js","slug":"Node-js","link":"/tags/Node-js/"},{"name":"汇编","slug":"汇编","link":"/tags/%E6%B1%87%E7%BC%96/"}],"categories":[{"name":"博客搭建","slug":"博客搭建","link":"/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"},{"name":"汇编","slug":"汇编","link":"/categories/%E6%B1%87%E7%BC%96/"}]}